// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: sdk_types/v1/tool_input.proto

package sdk_typesv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	structpb "google.golang.org/protobuf/types/known/structpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// GrepOutputMode specifies the output format for grep results.
type GrepOutputMode int32

const (
	GrepOutputMode_GREP_OUTPUT_MODE_UNSPECIFIED        GrepOutputMode = 0
	GrepOutputMode_GREP_OUTPUT_MODE_CONTENT            GrepOutputMode = 1
	GrepOutputMode_GREP_OUTPUT_MODE_FILES_WITH_MATCHES GrepOutputMode = 2
	GrepOutputMode_GREP_OUTPUT_MODE_COUNT              GrepOutputMode = 3
)

// Enum value maps for GrepOutputMode.
var (
	GrepOutputMode_name = map[int32]string{
		0: "GREP_OUTPUT_MODE_UNSPECIFIED",
		1: "GREP_OUTPUT_MODE_CONTENT",
		2: "GREP_OUTPUT_MODE_FILES_WITH_MATCHES",
		3: "GREP_OUTPUT_MODE_COUNT",
	}
	GrepOutputMode_value = map[string]int32{
		"GREP_OUTPUT_MODE_UNSPECIFIED":        0,
		"GREP_OUTPUT_MODE_CONTENT":            1,
		"GREP_OUTPUT_MODE_FILES_WITH_MATCHES": 2,
		"GREP_OUTPUT_MODE_COUNT":              3,
	}
)

func (x GrepOutputMode) Enum() *GrepOutputMode {
	p := new(GrepOutputMode)
	*p = x
	return p
}

func (x GrepOutputMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GrepOutputMode) Descriptor() protoreflect.EnumDescriptor {
	return file_sdk_types_v1_tool_input_proto_enumTypes[0].Descriptor()
}

func (GrepOutputMode) Type() protoreflect.EnumType {
	return &file_sdk_types_v1_tool_input_proto_enumTypes[0]
}

func (x GrepOutputMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GrepOutputMode.Descriptor instead.
func (GrepOutputMode) EnumDescriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{0}
}

// NotebookCellType specifies the type of a Jupyter notebook cell.
type NotebookCellType int32

const (
	NotebookCellType_NOTEBOOK_CELL_TYPE_UNSPECIFIED NotebookCellType = 0
	NotebookCellType_NOTEBOOK_CELL_TYPE_CODE        NotebookCellType = 1
	NotebookCellType_NOTEBOOK_CELL_TYPE_MARKDOWN    NotebookCellType = 2
)

// Enum value maps for NotebookCellType.
var (
	NotebookCellType_name = map[int32]string{
		0: "NOTEBOOK_CELL_TYPE_UNSPECIFIED",
		1: "NOTEBOOK_CELL_TYPE_CODE",
		2: "NOTEBOOK_CELL_TYPE_MARKDOWN",
	}
	NotebookCellType_value = map[string]int32{
		"NOTEBOOK_CELL_TYPE_UNSPECIFIED": 0,
		"NOTEBOOK_CELL_TYPE_CODE":        1,
		"NOTEBOOK_CELL_TYPE_MARKDOWN":    2,
	}
)

func (x NotebookCellType) Enum() *NotebookCellType {
	p := new(NotebookCellType)
	*p = x
	return p
}

func (x NotebookCellType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NotebookCellType) Descriptor() protoreflect.EnumDescriptor {
	return file_sdk_types_v1_tool_input_proto_enumTypes[1].Descriptor()
}

func (NotebookCellType) Type() protoreflect.EnumType {
	return &file_sdk_types_v1_tool_input_proto_enumTypes[1]
}

func (x NotebookCellType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NotebookCellType.Descriptor instead.
func (NotebookCellType) EnumDescriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{1}
}

// NotebookEditMode specifies the type of edit to perform on a notebook cell.
type NotebookEditMode int32

const (
	NotebookEditMode_NOTEBOOK_EDIT_MODE_UNSPECIFIED NotebookEditMode = 0
	NotebookEditMode_NOTEBOOK_EDIT_MODE_REPLACE     NotebookEditMode = 1
	NotebookEditMode_NOTEBOOK_EDIT_MODE_INSERT      NotebookEditMode = 2
	NotebookEditMode_NOTEBOOK_EDIT_MODE_DELETE      NotebookEditMode = 3
)

// Enum value maps for NotebookEditMode.
var (
	NotebookEditMode_name = map[int32]string{
		0: "NOTEBOOK_EDIT_MODE_UNSPECIFIED",
		1: "NOTEBOOK_EDIT_MODE_REPLACE",
		2: "NOTEBOOK_EDIT_MODE_INSERT",
		3: "NOTEBOOK_EDIT_MODE_DELETE",
	}
	NotebookEditMode_value = map[string]int32{
		"NOTEBOOK_EDIT_MODE_UNSPECIFIED": 0,
		"NOTEBOOK_EDIT_MODE_REPLACE":     1,
		"NOTEBOOK_EDIT_MODE_INSERT":      2,
		"NOTEBOOK_EDIT_MODE_DELETE":      3,
	}
)

func (x NotebookEditMode) Enum() *NotebookEditMode {
	p := new(NotebookEditMode)
	*p = x
	return p
}

func (x NotebookEditMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NotebookEditMode) Descriptor() protoreflect.EnumDescriptor {
	return file_sdk_types_v1_tool_input_proto_enumTypes[2].Descriptor()
}

func (NotebookEditMode) Type() protoreflect.EnumType {
	return &file_sdk_types_v1_tool_input_proto_enumTypes[2]
}

func (x NotebookEditMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NotebookEditMode.Descriptor instead.
func (NotebookEditMode) EnumDescriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{2}
}

// TodoStatus specifies the status of a todo item.
type TodoStatus int32

const (
	TodoStatus_TODO_STATUS_UNSPECIFIED TodoStatus = 0
	TodoStatus_TODO_STATUS_PENDING     TodoStatus = 1
	TodoStatus_TODO_STATUS_IN_PROGRESS TodoStatus = 2
	TodoStatus_TODO_STATUS_COMPLETED   TodoStatus = 3
)

// Enum value maps for TodoStatus.
var (
	TodoStatus_name = map[int32]string{
		0: "TODO_STATUS_UNSPECIFIED",
		1: "TODO_STATUS_PENDING",
		2: "TODO_STATUS_IN_PROGRESS",
		3: "TODO_STATUS_COMPLETED",
	}
	TodoStatus_value = map[string]int32{
		"TODO_STATUS_UNSPECIFIED": 0,
		"TODO_STATUS_PENDING":     1,
		"TODO_STATUS_IN_PROGRESS": 2,
		"TODO_STATUS_COMPLETED":   3,
	}
)

func (x TodoStatus) Enum() *TodoStatus {
	p := new(TodoStatus)
	*p = x
	return p
}

func (x TodoStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TodoStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_sdk_types_v1_tool_input_proto_enumTypes[3].Descriptor()
}

func (TodoStatus) Type() protoreflect.EnumType {
	return &file_sdk_types_v1_tool_input_proto_enumTypes[3]
}

func (x TodoStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TodoStatus.Descriptor instead.
func (TodoStatus) EnumDescriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{3}
}

// ToolInput is a union wrapper for all tool input types.
// Copied from https://platform.claude.com/docs/en/agent-sdk/typescript#tool-input-types
type ToolInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Input:
	//
	//	*ToolInput_Agent
	//	*ToolInput_AskUserQuestion
	//	*ToolInput_Bash
	//	*ToolInput_BashOutput
	//	*ToolInput_FileEdit
	//	*ToolInput_FileRead
	//	*ToolInput_FileWrite
	//	*ToolInput_Glob
	//	*ToolInput_Grep
	//	*ToolInput_KillShell
	//	*ToolInput_NotebookEdit
	//	*ToolInput_WebFetch
	//	*ToolInput_WebSearch
	//	*ToolInput_TodoWrite
	//	*ToolInput_ExitPlanMode
	//	*ToolInput_ListMcpResources
	//	*ToolInput_ReadMcpResource
	//	*ToolInput_McpTool
	Input         isToolInput_Input `protobuf_oneof:"input"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolInput) Reset() {
	*x = ToolInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolInput) ProtoMessage() {}

func (x *ToolInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolInput.ProtoReflect.Descriptor instead.
func (*ToolInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{0}
}

func (x *ToolInput) GetInput() isToolInput_Input {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *ToolInput) GetAgent() *AgentInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_Agent); ok {
			return x.Agent
		}
	}
	return nil
}

func (x *ToolInput) GetAskUserQuestion() *AskUserQuestionInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_AskUserQuestion); ok {
			return x.AskUserQuestion
		}
	}
	return nil
}

func (x *ToolInput) GetBash() *BashInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_Bash); ok {
			return x.Bash
		}
	}
	return nil
}

func (x *ToolInput) GetBashOutput() *BashOutputInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_BashOutput); ok {
			return x.BashOutput
		}
	}
	return nil
}

func (x *ToolInput) GetFileEdit() *FileEditInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_FileEdit); ok {
			return x.FileEdit
		}
	}
	return nil
}

func (x *ToolInput) GetFileRead() *FileReadInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_FileRead); ok {
			return x.FileRead
		}
	}
	return nil
}

func (x *ToolInput) GetFileWrite() *FileWriteInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_FileWrite); ok {
			return x.FileWrite
		}
	}
	return nil
}

func (x *ToolInput) GetGlob() *GlobInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_Glob); ok {
			return x.Glob
		}
	}
	return nil
}

func (x *ToolInput) GetGrep() *GrepInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_Grep); ok {
			return x.Grep
		}
	}
	return nil
}

func (x *ToolInput) GetKillShell() *KillShellInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_KillShell); ok {
			return x.KillShell
		}
	}
	return nil
}

func (x *ToolInput) GetNotebookEdit() *NotebookEditInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_NotebookEdit); ok {
			return x.NotebookEdit
		}
	}
	return nil
}

func (x *ToolInput) GetWebFetch() *WebFetchInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_WebFetch); ok {
			return x.WebFetch
		}
	}
	return nil
}

func (x *ToolInput) GetWebSearch() *WebSearchInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_WebSearch); ok {
			return x.WebSearch
		}
	}
	return nil
}

func (x *ToolInput) GetTodoWrite() *TodoWriteInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_TodoWrite); ok {
			return x.TodoWrite
		}
	}
	return nil
}

func (x *ToolInput) GetExitPlanMode() *ExitPlanModeInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_ExitPlanMode); ok {
			return x.ExitPlanMode
		}
	}
	return nil
}

func (x *ToolInput) GetListMcpResources() *ListMcpResourcesInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_ListMcpResources); ok {
			return x.ListMcpResources
		}
	}
	return nil
}

func (x *ToolInput) GetReadMcpResource() *ReadMcpResourceInput {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_ReadMcpResource); ok {
			return x.ReadMcpResource
		}
	}
	return nil
}

func (x *ToolInput) GetMcpTool() *structpb.Struct {
	if x != nil {
		if x, ok := x.Input.(*ToolInput_McpTool); ok {
			return x.McpTool
		}
	}
	return nil
}

type isToolInput_Input interface {
	isToolInput_Input()
}

type ToolInput_Agent struct {
	Agent *AgentInput `protobuf:"bytes,1,opt,name=agent,proto3,oneof"`
}

type ToolInput_AskUserQuestion struct {
	AskUserQuestion *AskUserQuestionInput `protobuf:"bytes,2,opt,name=ask_user_question,json=askUserQuestion,proto3,oneof"`
}

type ToolInput_Bash struct {
	Bash *BashInput `protobuf:"bytes,3,opt,name=bash,proto3,oneof"`
}

type ToolInput_BashOutput struct {
	BashOutput *BashOutputInput `protobuf:"bytes,4,opt,name=bash_output,json=bashOutput,proto3,oneof"`
}

type ToolInput_FileEdit struct {
	FileEdit *FileEditInput `protobuf:"bytes,5,opt,name=file_edit,json=fileEdit,proto3,oneof"`
}

type ToolInput_FileRead struct {
	FileRead *FileReadInput `protobuf:"bytes,6,opt,name=file_read,json=fileRead,proto3,oneof"`
}

type ToolInput_FileWrite struct {
	FileWrite *FileWriteInput `protobuf:"bytes,7,opt,name=file_write,json=fileWrite,proto3,oneof"`
}

type ToolInput_Glob struct {
	Glob *GlobInput `protobuf:"bytes,8,opt,name=glob,proto3,oneof"`
}

type ToolInput_Grep struct {
	Grep *GrepInput `protobuf:"bytes,9,opt,name=grep,proto3,oneof"`
}

type ToolInput_KillShell struct {
	KillShell *KillShellInput `protobuf:"bytes,10,opt,name=kill_shell,json=killShell,proto3,oneof"`
}

type ToolInput_NotebookEdit struct {
	NotebookEdit *NotebookEditInput `protobuf:"bytes,11,opt,name=notebook_edit,json=notebookEdit,proto3,oneof"`
}

type ToolInput_WebFetch struct {
	WebFetch *WebFetchInput `protobuf:"bytes,12,opt,name=web_fetch,json=webFetch,proto3,oneof"`
}

type ToolInput_WebSearch struct {
	WebSearch *WebSearchInput `protobuf:"bytes,13,opt,name=web_search,json=webSearch,proto3,oneof"`
}

type ToolInput_TodoWrite struct {
	TodoWrite *TodoWriteInput `protobuf:"bytes,14,opt,name=todo_write,json=todoWrite,proto3,oneof"`
}

type ToolInput_ExitPlanMode struct {
	ExitPlanMode *ExitPlanModeInput `protobuf:"bytes,15,opt,name=exit_plan_mode,json=exitPlanMode,proto3,oneof"`
}

type ToolInput_ListMcpResources struct {
	ListMcpResources *ListMcpResourcesInput `protobuf:"bytes,16,opt,name=list_mcp_resources,json=listMcpResources,proto3,oneof"`
}

type ToolInput_ReadMcpResource struct {
	ReadMcpResource *ReadMcpResourceInput `protobuf:"bytes,17,opt,name=read_mcp_resource,json=readMcpResource,proto3,oneof"`
}

type ToolInput_McpTool struct {
	McpTool *structpb.Struct `protobuf:"bytes,18,opt,name=mcp_tool,json=mcpTool,proto3,oneof"`
}

func (*ToolInput_Agent) isToolInput_Input() {}

func (*ToolInput_AskUserQuestion) isToolInput_Input() {}

func (*ToolInput_Bash) isToolInput_Input() {}

func (*ToolInput_BashOutput) isToolInput_Input() {}

func (*ToolInput_FileEdit) isToolInput_Input() {}

func (*ToolInput_FileRead) isToolInput_Input() {}

func (*ToolInput_FileWrite) isToolInput_Input() {}

func (*ToolInput_Glob) isToolInput_Input() {}

func (*ToolInput_Grep) isToolInput_Input() {}

func (*ToolInput_KillShell) isToolInput_Input() {}

func (*ToolInput_NotebookEdit) isToolInput_Input() {}

func (*ToolInput_WebFetch) isToolInput_Input() {}

func (*ToolInput_WebSearch) isToolInput_Input() {}

func (*ToolInput_TodoWrite) isToolInput_Input() {}

func (*ToolInput_ExitPlanMode) isToolInput_Input() {}

func (*ToolInput_ListMcpResources) isToolInput_Input() {}

func (*ToolInput_ReadMcpResource) isToolInput_Input() {}

func (*ToolInput_McpTool) isToolInput_Input() {}

// AgentInput is the input for the Task tool.
// Launches a new agent to handle complex, multi-step tasks autonomously.
type AgentInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A short (3-5 word) description of the task.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The task for the agent to perform.
	Prompt string `protobuf:"bytes,2,opt,name=prompt,proto3" json:"prompt,omitempty"`
	// The type of specialized agent to use for this task.
	SubagentType  string `protobuf:"bytes,3,opt,name=subagent_type,json=subagentType,proto3" json:"subagent_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentInput) Reset() {
	*x = AgentInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentInput) ProtoMessage() {}

func (x *AgentInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentInput.ProtoReflect.Descriptor instead.
func (*AgentInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{1}
}

func (x *AgentInput) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AgentInput) GetPrompt() string {
	if x != nil {
		return x.Prompt
	}
	return ""
}

func (x *AgentInput) GetSubagentType() string {
	if x != nil {
		return x.SubagentType
	}
	return ""
}

// QuestionOption represents a single choice option within a question.
type QuestionOption struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Display text for this option (1-5 words).
	Label string `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	// Explanation of what this option means.
	Description   string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QuestionOption) Reset() {
	*x = QuestionOption{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuestionOption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuestionOption) ProtoMessage() {}

func (x *QuestionOption) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuestionOption.ProtoReflect.Descriptor instead.
func (*QuestionOption) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{2}
}

func (x *QuestionOption) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *QuestionOption) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

// Question represents a single question to ask the user.
type Question struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The complete question to ask the user.
	Question string `protobuf:"bytes,1,opt,name=question,proto3" json:"question,omitempty"`
	// Very short label displayed as a chip/tag (max 12 chars).
	Header string `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// The available choices (2-4 options).
	Options []*QuestionOption `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	// Set to true to allow multiple selections.
	MultiSelect   bool `protobuf:"varint,4,opt,name=multi_select,json=multiSelect,proto3" json:"multi_select,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Question) Reset() {
	*x = Question{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Question) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Question) ProtoMessage() {}

func (x *Question) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Question.ProtoReflect.Descriptor instead.
func (*Question) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{3}
}

func (x *Question) GetQuestion() string {
	if x != nil {
		return x.Question
	}
	return ""
}

func (x *Question) GetHeader() string {
	if x != nil {
		return x.Header
	}
	return ""
}

func (x *Question) GetOptions() []*QuestionOption {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Question) GetMultiSelect() bool {
	if x != nil {
		return x.MultiSelect
	}
	return false
}

// AskUserQuestionInput asks the user clarifying questions during execution.
type AskUserQuestionInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Questions to ask the user (1-4 questions).
	Questions []*Question `protobuf:"bytes,1,rep,name=questions,proto3" json:"questions,omitempty"`
	// User answers populated by the permission system.
	// Maps question text to selected option label(s).
	Answers       map[string]string `protobuf:"bytes,2,rep,name=answers,proto3" json:"answers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AskUserQuestionInput) Reset() {
	*x = AskUserQuestionInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AskUserQuestionInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AskUserQuestionInput) ProtoMessage() {}

func (x *AskUserQuestionInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AskUserQuestionInput.ProtoReflect.Descriptor instead.
func (*AskUserQuestionInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{4}
}

func (x *AskUserQuestionInput) GetQuestions() []*Question {
	if x != nil {
		return x.Questions
	}
	return nil
}

func (x *AskUserQuestionInput) GetAnswers() map[string]string {
	if x != nil {
		return x.Answers
	}
	return nil
}

// BashInput executes bash commands in a persistent shell session.
type BashInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The command to execute.
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	// Optional timeout in milliseconds (max 600000).
	Timeout *int32 `protobuf:"varint,2,opt,name=timeout,proto3,oneof" json:"timeout,omitempty"`
	// Clear, concise description of what this command does.
	Description *string `protobuf:"bytes,3,opt,name=description,proto3,oneof" json:"description,omitempty"`
	// Set to true to run this command in the background.
	RunInBackground *bool `protobuf:"varint,4,opt,name=run_in_background,json=runInBackground,proto3,oneof" json:"run_in_background,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BashInput) Reset() {
	*x = BashInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BashInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BashInput) ProtoMessage() {}

func (x *BashInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BashInput.ProtoReflect.Descriptor instead.
func (*BashInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{5}
}

func (x *BashInput) GetCommand() string {
	if x != nil {
		return x.Command
	}
	return ""
}

func (x *BashInput) GetTimeout() int32 {
	if x != nil && x.Timeout != nil {
		return *x.Timeout
	}
	return 0
}

func (x *BashInput) GetDescription() string {
	if x != nil && x.Description != nil {
		return *x.Description
	}
	return ""
}

func (x *BashInput) GetRunInBackground() bool {
	if x != nil && x.RunInBackground != nil {
		return *x.RunInBackground
	}
	return false
}

// BashOutputInput retrieves output from a running or completed background bash shell.
type BashOutputInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the background shell to retrieve output from.
	BashId string `protobuf:"bytes,1,opt,name=bash_id,json=bashId,proto3" json:"bash_id,omitempty"`
	// Optional regex to filter output lines.
	Filter        *string `protobuf:"bytes,2,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BashOutputInput) Reset() {
	*x = BashOutputInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BashOutputInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BashOutputInput) ProtoMessage() {}

func (x *BashOutputInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BashOutputInput.ProtoReflect.Descriptor instead.
func (*BashOutputInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{6}
}

func (x *BashOutputInput) GetBashId() string {
	if x != nil {
		return x.BashId
	}
	return ""
}

func (x *BashOutputInput) GetFilter() string {
	if x != nil && x.Filter != nil {
		return *x.Filter
	}
	return ""
}

// FileEditInput performs exact string replacements in files.
type FileEditInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The absolute path to the file to modify.
	FilePath string `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// The text to replace.
	OldString string `protobuf:"bytes,2,opt,name=old_string,json=oldString,proto3" json:"old_string,omitempty"`
	// The text to replace it with (must be different from old_string).
	NewString string `protobuf:"bytes,3,opt,name=new_string,json=newString,proto3" json:"new_string,omitempty"`
	// Replace all occurrences of old_string (default false).
	ReplaceAll    *bool `protobuf:"varint,4,opt,name=replace_all,json=replaceAll,proto3,oneof" json:"replace_all,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileEditInput) Reset() {
	*x = FileEditInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileEditInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileEditInput) ProtoMessage() {}

func (x *FileEditInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileEditInput.ProtoReflect.Descriptor instead.
func (*FileEditInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{7}
}

func (x *FileEditInput) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileEditInput) GetOldString() string {
	if x != nil {
		return x.OldString
	}
	return ""
}

func (x *FileEditInput) GetNewString() string {
	if x != nil {
		return x.NewString
	}
	return ""
}

func (x *FileEditInput) GetReplaceAll() bool {
	if x != nil && x.ReplaceAll != nil {
		return *x.ReplaceAll
	}
	return false
}

// FileReadInput reads files from the local filesystem.
type FileReadInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The absolute path to the file to read.
	FilePath string `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// The line number to start reading from.
	Offset *int32 `protobuf:"varint,2,opt,name=offset,proto3,oneof" json:"offset,omitempty"`
	// The number of lines to read.
	Limit         *int32 `protobuf:"varint,3,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileReadInput) Reset() {
	*x = FileReadInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileReadInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileReadInput) ProtoMessage() {}

func (x *FileReadInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileReadInput.ProtoReflect.Descriptor instead.
func (*FileReadInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{8}
}

func (x *FileReadInput) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileReadInput) GetOffset() int32 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

func (x *FileReadInput) GetLimit() int32 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

// FileWriteInput writes a file to the local filesystem.
type FileWriteInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The absolute path to the file to write.
	FilePath string `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// The content to write to the file.
	Content       string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileWriteInput) Reset() {
	*x = FileWriteInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileWriteInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileWriteInput) ProtoMessage() {}

func (x *FileWriteInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileWriteInput.ProtoReflect.Descriptor instead.
func (*FileWriteInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{9}
}

func (x *FileWriteInput) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileWriteInput) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

// GlobInput performs fast file pattern matching.
type GlobInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The glob pattern to match files against.
	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// The directory to search in (defaults to cwd).
	Path          *string `protobuf:"bytes,2,opt,name=path,proto3,oneof" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GlobInput) Reset() {
	*x = GlobInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GlobInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobInput) ProtoMessage() {}

func (x *GlobInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobInput.ProtoReflect.Descriptor instead.
func (*GlobInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{10}
}

func (x *GlobInput) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *GlobInput) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

// GrepInput searches file contents using ripgrep with regex support.
type GrepInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The regular expression pattern to search for.
	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// File or directory to search in (defaults to cwd).
	Path *string `protobuf:"bytes,2,opt,name=path,proto3,oneof" json:"path,omitempty"`
	// Glob pattern to filter files (e.g. "*.js").
	Glob *string `protobuf:"bytes,3,opt,name=glob,proto3,oneof" json:"glob,omitempty"`
	// File type to search (e.g. "js", "py", "rust").
	Type *string `protobuf:"bytes,4,opt,name=type,proto3,oneof" json:"type,omitempty"`
	// Output mode.
	OutputMode GrepOutputMode `protobuf:"varint,5,opt,name=output_mode,json=outputMode,proto3,enum=sdk_types.v1.GrepOutputMode" json:"output_mode,omitempty"`
	// Case insensitive search.
	CaseInsensitive *bool `protobuf:"varint,6,opt,name=case_insensitive,json=caseInsensitive,proto3,oneof" json:"case_insensitive,omitempty"`
	// Show line numbers (for content mode).
	ShowLineNumbers *bool `protobuf:"varint,7,opt,name=show_line_numbers,json=showLineNumbers,proto3,oneof" json:"show_line_numbers,omitempty"`
	// Lines to show before each match.
	BeforeContext *int32 `protobuf:"varint,8,opt,name=before_context,json=beforeContext,proto3,oneof" json:"before_context,omitempty"`
	// Lines to show after each match.
	AfterContext *int32 `protobuf:"varint,9,opt,name=after_context,json=afterContext,proto3,oneof" json:"after_context,omitempty"`
	// Lines to show before and after each match.
	Context *int32 `protobuf:"varint,10,opt,name=context,proto3,oneof" json:"context,omitempty"`
	// Limit output to first N lines/entries.
	HeadLimit *int32 `protobuf:"varint,11,opt,name=head_limit,json=headLimit,proto3,oneof" json:"head_limit,omitempty"`
	// Enable multiline mode.
	Multiline     *bool `protobuf:"varint,12,opt,name=multiline,proto3,oneof" json:"multiline,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrepInput) Reset() {
	*x = GrepInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrepInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrepInput) ProtoMessage() {}

func (x *GrepInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrepInput.ProtoReflect.Descriptor instead.
func (*GrepInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{11}
}

func (x *GrepInput) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *GrepInput) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *GrepInput) GetGlob() string {
	if x != nil && x.Glob != nil {
		return *x.Glob
	}
	return ""
}

func (x *GrepInput) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *GrepInput) GetOutputMode() GrepOutputMode {
	if x != nil {
		return x.OutputMode
	}
	return GrepOutputMode_GREP_OUTPUT_MODE_UNSPECIFIED
}

func (x *GrepInput) GetCaseInsensitive() bool {
	if x != nil && x.CaseInsensitive != nil {
		return *x.CaseInsensitive
	}
	return false
}

func (x *GrepInput) GetShowLineNumbers() bool {
	if x != nil && x.ShowLineNumbers != nil {
		return *x.ShowLineNumbers
	}
	return false
}

func (x *GrepInput) GetBeforeContext() int32 {
	if x != nil && x.BeforeContext != nil {
		return *x.BeforeContext
	}
	return 0
}

func (x *GrepInput) GetAfterContext() int32 {
	if x != nil && x.AfterContext != nil {
		return *x.AfterContext
	}
	return 0
}

func (x *GrepInput) GetContext() int32 {
	if x != nil && x.Context != nil {
		return *x.Context
	}
	return 0
}

func (x *GrepInput) GetHeadLimit() int32 {
	if x != nil && x.HeadLimit != nil {
		return *x.HeadLimit
	}
	return 0
}

func (x *GrepInput) GetMultiline() bool {
	if x != nil && x.Multiline != nil {
		return *x.Multiline
	}
	return false
}

// KillShellInput kills a running background bash shell by its ID.
type KillShellInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the background shell to kill.
	ShellId       string `protobuf:"bytes,1,opt,name=shell_id,json=shellId,proto3" json:"shell_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KillShellInput) Reset() {
	*x = KillShellInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KillShellInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KillShellInput) ProtoMessage() {}

func (x *KillShellInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KillShellInput.ProtoReflect.Descriptor instead.
func (*KillShellInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{12}
}

func (x *KillShellInput) GetShellId() string {
	if x != nil {
		return x.ShellId
	}
	return ""
}

// NotebookEditInput edits cells in Jupyter notebook files.
type NotebookEditInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The absolute path to the Jupyter notebook file.
	NotebookPath string `protobuf:"bytes,1,opt,name=notebook_path,json=notebookPath,proto3" json:"notebook_path,omitempty"`
	// The ID of the cell to edit.
	CellId *string `protobuf:"bytes,2,opt,name=cell_id,json=cellId,proto3,oneof" json:"cell_id,omitempty"`
	// The new source for the cell.
	NewSource string `protobuf:"bytes,3,opt,name=new_source,json=newSource,proto3" json:"new_source,omitempty"`
	// The type of the cell.
	CellType NotebookCellType `protobuf:"varint,4,opt,name=cell_type,json=cellType,proto3,enum=sdk_types.v1.NotebookCellType" json:"cell_type,omitempty"`
	// The type of edit.
	EditMode      NotebookEditMode `protobuf:"varint,5,opt,name=edit_mode,json=editMode,proto3,enum=sdk_types.v1.NotebookEditMode" json:"edit_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NotebookEditInput) Reset() {
	*x = NotebookEditInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NotebookEditInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NotebookEditInput) ProtoMessage() {}

func (x *NotebookEditInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NotebookEditInput.ProtoReflect.Descriptor instead.
func (*NotebookEditInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{13}
}

func (x *NotebookEditInput) GetNotebookPath() string {
	if x != nil {
		return x.NotebookPath
	}
	return ""
}

func (x *NotebookEditInput) GetCellId() string {
	if x != nil && x.CellId != nil {
		return *x.CellId
	}
	return ""
}

func (x *NotebookEditInput) GetNewSource() string {
	if x != nil {
		return x.NewSource
	}
	return ""
}

func (x *NotebookEditInput) GetCellType() NotebookCellType {
	if x != nil {
		return x.CellType
	}
	return NotebookCellType_NOTEBOOK_CELL_TYPE_UNSPECIFIED
}

func (x *NotebookEditInput) GetEditMode() NotebookEditMode {
	if x != nil {
		return x.EditMode
	}
	return NotebookEditMode_NOTEBOOK_EDIT_MODE_UNSPECIFIED
}

// WebFetchInput fetches content from a URL and processes it with an AI model.
type WebFetchInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The URL to fetch content from.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// The prompt to run on the fetched content.
	Prompt        string `protobuf:"bytes,2,opt,name=prompt,proto3" json:"prompt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WebFetchInput) Reset() {
	*x = WebFetchInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebFetchInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebFetchInput) ProtoMessage() {}

func (x *WebFetchInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebFetchInput.ProtoReflect.Descriptor instead.
func (*WebFetchInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{14}
}

func (x *WebFetchInput) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *WebFetchInput) GetPrompt() string {
	if x != nil {
		return x.Prompt
	}
	return ""
}

// WebSearchInput searches the web and returns formatted results.
type WebSearchInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The search query to use.
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// Only include results from these domains.
	AllowedDomains []string `protobuf:"bytes,2,rep,name=allowed_domains,json=allowedDomains,proto3" json:"allowed_domains,omitempty"`
	// Never include results from these domains.
	BlockedDomains []string `protobuf:"bytes,3,rep,name=blocked_domains,json=blockedDomains,proto3" json:"blocked_domains,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WebSearchInput) Reset() {
	*x = WebSearchInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebSearchInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebSearchInput) ProtoMessage() {}

func (x *WebSearchInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebSearchInput.ProtoReflect.Descriptor instead.
func (*WebSearchInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{15}
}

func (x *WebSearchInput) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *WebSearchInput) GetAllowedDomains() []string {
	if x != nil {
		return x.AllowedDomains
	}
	return nil
}

func (x *WebSearchInput) GetBlockedDomains() []string {
	if x != nil {
		return x.BlockedDomains
	}
	return nil
}

// TodoItem represents a single task in the todo list.
type TodoItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The task description.
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// The task status.
	Status TodoStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sdk_types.v1.TodoStatus" json:"status,omitempty"`
	// Active form of the task description.
	ActiveForm    string `protobuf:"bytes,3,opt,name=active_form,json=activeForm,proto3" json:"active_form,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TodoItem) Reset() {
	*x = TodoItem{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TodoItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TodoItem) ProtoMessage() {}

func (x *TodoItem) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TodoItem.ProtoReflect.Descriptor instead.
func (*TodoItem) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{16}
}

func (x *TodoItem) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *TodoItem) GetStatus() TodoStatus {
	if x != nil {
		return x.Status
	}
	return TodoStatus_TODO_STATUS_UNSPECIFIED
}

func (x *TodoItem) GetActiveForm() string {
	if x != nil {
		return x.ActiveForm
	}
	return ""
}

// TodoWriteInput creates and manages a structured task list.
type TodoWriteInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The updated todo list.
	Todos         []*TodoItem `protobuf:"bytes,1,rep,name=todos,proto3" json:"todos,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TodoWriteInput) Reset() {
	*x = TodoWriteInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TodoWriteInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TodoWriteInput) ProtoMessage() {}

func (x *TodoWriteInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TodoWriteInput.ProtoReflect.Descriptor instead.
func (*TodoWriteInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{17}
}

func (x *TodoWriteInput) GetTodos() []*TodoItem {
	if x != nil {
		return x.Todos
	}
	return nil
}

// ExitPlanModeInput exits planning mode and prompts the user to approve the plan.
type ExitPlanModeInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The plan to run by the user for approval.
	Plan          string `protobuf:"bytes,1,opt,name=plan,proto3" json:"plan,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExitPlanModeInput) Reset() {
	*x = ExitPlanModeInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExitPlanModeInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExitPlanModeInput) ProtoMessage() {}

func (x *ExitPlanModeInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExitPlanModeInput.ProtoReflect.Descriptor instead.
func (*ExitPlanModeInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{18}
}

func (x *ExitPlanModeInput) GetPlan() string {
	if x != nil {
		return x.Plan
	}
	return ""
}

// ListMcpResourcesInput lists available MCP resources from connected servers.
type ListMcpResourcesInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional server name to filter resources by.
	Server        *string `protobuf:"bytes,1,opt,name=server,proto3,oneof" json:"server,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMcpResourcesInput) Reset() {
	*x = ListMcpResourcesInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMcpResourcesInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMcpResourcesInput) ProtoMessage() {}

func (x *ListMcpResourcesInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMcpResourcesInput.ProtoReflect.Descriptor instead.
func (*ListMcpResourcesInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{19}
}

func (x *ListMcpResourcesInput) GetServer() string {
	if x != nil && x.Server != nil {
		return *x.Server
	}
	return ""
}

// ReadMcpResourceInput reads a specific MCP resource from a server.
type ReadMcpResourceInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The MCP server name.
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// The resource URI to read.
	Uri           string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadMcpResourceInput) Reset() {
	*x = ReadMcpResourceInput{}
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadMcpResourceInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadMcpResourceInput) ProtoMessage() {}

func (x *ReadMcpResourceInput) ProtoReflect() protoreflect.Message {
	mi := &file_sdk_types_v1_tool_input_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadMcpResourceInput.ProtoReflect.Descriptor instead.
func (*ReadMcpResourceInput) Descriptor() ([]byte, []int) {
	return file_sdk_types_v1_tool_input_proto_rawDescGZIP(), []int{20}
}

func (x *ReadMcpResourceInput) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *ReadMcpResourceInput) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

var File_sdk_types_v1_tool_input_proto protoreflect.FileDescriptor

const file_sdk_types_v1_tool_input_proto_rawDesc = "" +
	"\n" +
	"\x1dsdk_types/v1/tool_input.proto\x12\fsdk_types.v1\x1a\x1cgoogle/protobuf/struct.proto\"\x85\t\n" +
	"\tToolInput\x120\n" +
	"\x05agent\x18\x01 \x01(\v2\x18.sdk_types.v1.AgentInputH\x00R\x05agent\x12P\n" +
	"\x11ask_user_question\x18\x02 \x01(\v2\".sdk_types.v1.AskUserQuestionInputH\x00R\x0faskUserQuestion\x12-\n" +
	"\x04bash\x18\x03 \x01(\v2\x17.sdk_types.v1.BashInputH\x00R\x04bash\x12@\n" +
	"\vbash_output\x18\x04 \x01(\v2\x1d.sdk_types.v1.BashOutputInputH\x00R\n" +
	"bashOutput\x12:\n" +
	"\tfile_edit\x18\x05 \x01(\v2\x1b.sdk_types.v1.FileEditInputH\x00R\bfileEdit\x12:\n" +
	"\tfile_read\x18\x06 \x01(\v2\x1b.sdk_types.v1.FileReadInputH\x00R\bfileRead\x12=\n" +
	"\n" +
	"file_write\x18\a \x01(\v2\x1c.sdk_types.v1.FileWriteInputH\x00R\tfileWrite\x12-\n" +
	"\x04glob\x18\b \x01(\v2\x17.sdk_types.v1.GlobInputH\x00R\x04glob\x12-\n" +
	"\x04grep\x18\t \x01(\v2\x17.sdk_types.v1.GrepInputH\x00R\x04grep\x12=\n" +
	"\n" +
	"kill_shell\x18\n" +
	" \x01(\v2\x1c.sdk_types.v1.KillShellInputH\x00R\tkillShell\x12F\n" +
	"\rnotebook_edit\x18\v \x01(\v2\x1f.sdk_types.v1.NotebookEditInputH\x00R\fnotebookEdit\x12:\n" +
	"\tweb_fetch\x18\f \x01(\v2\x1b.sdk_types.v1.WebFetchInputH\x00R\bwebFetch\x12=\n" +
	"\n" +
	"web_search\x18\r \x01(\v2\x1c.sdk_types.v1.WebSearchInputH\x00R\twebSearch\x12=\n" +
	"\n" +
	"todo_write\x18\x0e \x01(\v2\x1c.sdk_types.v1.TodoWriteInputH\x00R\ttodoWrite\x12G\n" +
	"\x0eexit_plan_mode\x18\x0f \x01(\v2\x1f.sdk_types.v1.ExitPlanModeInputH\x00R\fexitPlanMode\x12S\n" +
	"\x12list_mcp_resources\x18\x10 \x01(\v2#.sdk_types.v1.ListMcpResourcesInputH\x00R\x10listMcpResources\x12P\n" +
	"\x11read_mcp_resource\x18\x11 \x01(\v2\".sdk_types.v1.ReadMcpResourceInputH\x00R\x0freadMcpResource\x124\n" +
	"\bmcp_tool\x18\x12 \x01(\v2\x17.google.protobuf.StructH\x00R\amcpToolB\a\n" +
	"\x05input\"k\n" +
	"\n" +
	"AgentInput\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12\x16\n" +
	"\x06prompt\x18\x02 \x01(\tR\x06prompt\x12#\n" +
	"\rsubagent_type\x18\x03 \x01(\tR\fsubagentType\"H\n" +
	"\x0eQuestionOption\x12\x14\n" +
	"\x05label\x18\x01 \x01(\tR\x05label\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\"\x99\x01\n" +
	"\bQuestion\x12\x1a\n" +
	"\bquestion\x18\x01 \x01(\tR\bquestion\x12\x16\n" +
	"\x06header\x18\x02 \x01(\tR\x06header\x126\n" +
	"\aoptions\x18\x03 \x03(\v2\x1c.sdk_types.v1.QuestionOptionR\aoptions\x12!\n" +
	"\fmulti_select\x18\x04 \x01(\bR\vmultiSelect\"\xd3\x01\n" +
	"\x14AskUserQuestionInput\x124\n" +
	"\tquestions\x18\x01 \x03(\v2\x16.sdk_types.v1.QuestionR\tquestions\x12I\n" +
	"\aanswers\x18\x02 \x03(\v2/.sdk_types.v1.AskUserQuestionInput.AnswersEntryR\aanswers\x1a:\n" +
	"\fAnswersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xce\x01\n" +
	"\tBashInput\x12\x18\n" +
	"\acommand\x18\x01 \x01(\tR\acommand\x12\x1d\n" +
	"\atimeout\x18\x02 \x01(\x05H\x00R\atimeout\x88\x01\x01\x12%\n" +
	"\vdescription\x18\x03 \x01(\tH\x01R\vdescription\x88\x01\x01\x12/\n" +
	"\x11run_in_background\x18\x04 \x01(\bH\x02R\x0frunInBackground\x88\x01\x01B\n" +
	"\n" +
	"\b_timeoutB\x0e\n" +
	"\f_descriptionB\x14\n" +
	"\x12_run_in_background\"R\n" +
	"\x0fBashOutputInput\x12\x17\n" +
	"\abash_id\x18\x01 \x01(\tR\x06bashId\x12\x1b\n" +
	"\x06filter\x18\x02 \x01(\tH\x00R\x06filter\x88\x01\x01B\t\n" +
	"\a_filter\"\xa0\x01\n" +
	"\rFileEditInput\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12\x1d\n" +
	"\n" +
	"old_string\x18\x02 \x01(\tR\toldString\x12\x1d\n" +
	"\n" +
	"new_string\x18\x03 \x01(\tR\tnewString\x12$\n" +
	"\vreplace_all\x18\x04 \x01(\bH\x00R\n" +
	"replaceAll\x88\x01\x01B\x0e\n" +
	"\f_replace_all\"y\n" +
	"\rFileReadInput\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12\x1b\n" +
	"\x06offset\x18\x02 \x01(\x05H\x00R\x06offset\x88\x01\x01\x12\x19\n" +
	"\x05limit\x18\x03 \x01(\x05H\x01R\x05limit\x88\x01\x01B\t\n" +
	"\a_offsetB\b\n" +
	"\x06_limit\"G\n" +
	"\x0eFileWriteInput\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12\x18\n" +
	"\acontent\x18\x02 \x01(\tR\acontent\"G\n" +
	"\tGlobInput\x12\x18\n" +
	"\apattern\x18\x01 \x01(\tR\apattern\x12\x17\n" +
	"\x04path\x18\x02 \x01(\tH\x00R\x04path\x88\x01\x01B\a\n" +
	"\x05_path\"\xe0\x04\n" +
	"\tGrepInput\x12\x18\n" +
	"\apattern\x18\x01 \x01(\tR\apattern\x12\x17\n" +
	"\x04path\x18\x02 \x01(\tH\x00R\x04path\x88\x01\x01\x12\x17\n" +
	"\x04glob\x18\x03 \x01(\tH\x01R\x04glob\x88\x01\x01\x12\x17\n" +
	"\x04type\x18\x04 \x01(\tH\x02R\x04type\x88\x01\x01\x12=\n" +
	"\voutput_mode\x18\x05 \x01(\x0e2\x1c.sdk_types.v1.GrepOutputModeR\n" +
	"outputMode\x12.\n" +
	"\x10case_insensitive\x18\x06 \x01(\bH\x03R\x0fcaseInsensitive\x88\x01\x01\x12/\n" +
	"\x11show_line_numbers\x18\a \x01(\bH\x04R\x0fshowLineNumbers\x88\x01\x01\x12*\n" +
	"\x0ebefore_context\x18\b \x01(\x05H\x05R\rbeforeContext\x88\x01\x01\x12(\n" +
	"\rafter_context\x18\t \x01(\x05H\x06R\fafterContext\x88\x01\x01\x12\x1d\n" +
	"\acontext\x18\n" +
	" \x01(\x05H\aR\acontext\x88\x01\x01\x12\"\n" +
	"\n" +
	"head_limit\x18\v \x01(\x05H\bR\theadLimit\x88\x01\x01\x12!\n" +
	"\tmultiline\x18\f \x01(\bH\tR\tmultiline\x88\x01\x01B\a\n" +
	"\x05_pathB\a\n" +
	"\x05_globB\a\n" +
	"\x05_typeB\x13\n" +
	"\x11_case_insensitiveB\x14\n" +
	"\x12_show_line_numbersB\x11\n" +
	"\x0f_before_contextB\x10\n" +
	"\x0e_after_contextB\n" +
	"\n" +
	"\b_contextB\r\n" +
	"\v_head_limitB\f\n" +
	"\n" +
	"_multiline\"+\n" +
	"\x0eKillShellInput\x12\x19\n" +
	"\bshell_id\x18\x01 \x01(\tR\ashellId\"\xfb\x01\n" +
	"\x11NotebookEditInput\x12#\n" +
	"\rnotebook_path\x18\x01 \x01(\tR\fnotebookPath\x12\x1c\n" +
	"\acell_id\x18\x02 \x01(\tH\x00R\x06cellId\x88\x01\x01\x12\x1d\n" +
	"\n" +
	"new_source\x18\x03 \x01(\tR\tnewSource\x12;\n" +
	"\tcell_type\x18\x04 \x01(\x0e2\x1e.sdk_types.v1.NotebookCellTypeR\bcellType\x12;\n" +
	"\tedit_mode\x18\x05 \x01(\x0e2\x1e.sdk_types.v1.NotebookEditModeR\beditModeB\n" +
	"\n" +
	"\b_cell_id\"9\n" +
	"\rWebFetchInput\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x16\n" +
	"\x06prompt\x18\x02 \x01(\tR\x06prompt\"x\n" +
	"\x0eWebSearchInput\x12\x14\n" +
	"\x05query\x18\x01 \x01(\tR\x05query\x12'\n" +
	"\x0fallowed_domains\x18\x02 \x03(\tR\x0eallowedDomains\x12'\n" +
	"\x0fblocked_domains\x18\x03 \x03(\tR\x0eblockedDomains\"w\n" +
	"\bTodoItem\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x120\n" +
	"\x06status\x18\x02 \x01(\x0e2\x18.sdk_types.v1.TodoStatusR\x06status\x12\x1f\n" +
	"\vactive_form\x18\x03 \x01(\tR\n" +
	"activeForm\">\n" +
	"\x0eTodoWriteInput\x12,\n" +
	"\x05todos\x18\x01 \x03(\v2\x16.sdk_types.v1.TodoItemR\x05todos\"'\n" +
	"\x11ExitPlanModeInput\x12\x12\n" +
	"\x04plan\x18\x01 \x01(\tR\x04plan\"?\n" +
	"\x15ListMcpResourcesInput\x12\x1b\n" +
	"\x06server\x18\x01 \x01(\tH\x00R\x06server\x88\x01\x01B\t\n" +
	"\a_server\"@\n" +
	"\x14ReadMcpResourceInput\x12\x16\n" +
	"\x06server\x18\x01 \x01(\tR\x06server\x12\x10\n" +
	"\x03uri\x18\x02 \x01(\tR\x03uri*\x95\x01\n" +
	"\x0eGrepOutputMode\x12 \n" +
	"\x1cGREP_OUTPUT_MODE_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18GREP_OUTPUT_MODE_CONTENT\x10\x01\x12'\n" +
	"#GREP_OUTPUT_MODE_FILES_WITH_MATCHES\x10\x02\x12\x1a\n" +
	"\x16GREP_OUTPUT_MODE_COUNT\x10\x03*t\n" +
	"\x10NotebookCellType\x12\"\n" +
	"\x1eNOTEBOOK_CELL_TYPE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17NOTEBOOK_CELL_TYPE_CODE\x10\x01\x12\x1f\n" +
	"\x1bNOTEBOOK_CELL_TYPE_MARKDOWN\x10\x02*\x94\x01\n" +
	"\x10NotebookEditMode\x12\"\n" +
	"\x1eNOTEBOOK_EDIT_MODE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aNOTEBOOK_EDIT_MODE_REPLACE\x10\x01\x12\x1d\n" +
	"\x19NOTEBOOK_EDIT_MODE_INSERT\x10\x02\x12\x1d\n" +
	"\x19NOTEBOOK_EDIT_MODE_DELETE\x10\x03*z\n" +
	"\n" +
	"TodoStatus\x12\x1b\n" +
	"\x17TODO_STATUS_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13TODO_STATUS_PENDING\x10\x01\x12\x1b\n" +
	"\x17TODO_STATUS_IN_PROGRESS\x10\x02\x12\x19\n" +
	"\x15TODO_STATUS_COMPLETED\x10\x03B\xba\x01\n" +
	"\x10com.sdk_types.v1B\x0eToolInputProtoP\x01ZIgithub.com/ngicks/crabswarm/pkg/api/gen/proto/go/sdk_types/v1;sdk_typesv1\xa2\x02\x03SXX\xaa\x02\vSdkTypes.V1\xca\x02\vSdkTypes\\V1\xe2\x02\x17SdkTypes\\V1\\GPBMetadata\xea\x02\fSdkTypes::V1b\x06proto3"

var (
	file_sdk_types_v1_tool_input_proto_rawDescOnce sync.Once
	file_sdk_types_v1_tool_input_proto_rawDescData []byte
)

func file_sdk_types_v1_tool_input_proto_rawDescGZIP() []byte {
	file_sdk_types_v1_tool_input_proto_rawDescOnce.Do(func() {
		file_sdk_types_v1_tool_input_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_sdk_types_v1_tool_input_proto_rawDesc), len(file_sdk_types_v1_tool_input_proto_rawDesc)))
	})
	return file_sdk_types_v1_tool_input_proto_rawDescData
}

var file_sdk_types_v1_tool_input_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_sdk_types_v1_tool_input_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_sdk_types_v1_tool_input_proto_goTypes = []any{
	(GrepOutputMode)(0),           // 0: sdk_types.v1.GrepOutputMode
	(NotebookCellType)(0),         // 1: sdk_types.v1.NotebookCellType
	(NotebookEditMode)(0),         // 2: sdk_types.v1.NotebookEditMode
	(TodoStatus)(0),               // 3: sdk_types.v1.TodoStatus
	(*ToolInput)(nil),             // 4: sdk_types.v1.ToolInput
	(*AgentInput)(nil),            // 5: sdk_types.v1.AgentInput
	(*QuestionOption)(nil),        // 6: sdk_types.v1.QuestionOption
	(*Question)(nil),              // 7: sdk_types.v1.Question
	(*AskUserQuestionInput)(nil),  // 8: sdk_types.v1.AskUserQuestionInput
	(*BashInput)(nil),             // 9: sdk_types.v1.BashInput
	(*BashOutputInput)(nil),       // 10: sdk_types.v1.BashOutputInput
	(*FileEditInput)(nil),         // 11: sdk_types.v1.FileEditInput
	(*FileReadInput)(nil),         // 12: sdk_types.v1.FileReadInput
	(*FileWriteInput)(nil),        // 13: sdk_types.v1.FileWriteInput
	(*GlobInput)(nil),             // 14: sdk_types.v1.GlobInput
	(*GrepInput)(nil),             // 15: sdk_types.v1.GrepInput
	(*KillShellInput)(nil),        // 16: sdk_types.v1.KillShellInput
	(*NotebookEditInput)(nil),     // 17: sdk_types.v1.NotebookEditInput
	(*WebFetchInput)(nil),         // 18: sdk_types.v1.WebFetchInput
	(*WebSearchInput)(nil),        // 19: sdk_types.v1.WebSearchInput
	(*TodoItem)(nil),              // 20: sdk_types.v1.TodoItem
	(*TodoWriteInput)(nil),        // 21: sdk_types.v1.TodoWriteInput
	(*ExitPlanModeInput)(nil),     // 22: sdk_types.v1.ExitPlanModeInput
	(*ListMcpResourcesInput)(nil), // 23: sdk_types.v1.ListMcpResourcesInput
	(*ReadMcpResourceInput)(nil),  // 24: sdk_types.v1.ReadMcpResourceInput
	nil,                           // 25: sdk_types.v1.AskUserQuestionInput.AnswersEntry
	(*structpb.Struct)(nil),       // 26: google.protobuf.Struct
}
var file_sdk_types_v1_tool_input_proto_depIdxs = []int32{
	5,  // 0: sdk_types.v1.ToolInput.agent:type_name -> sdk_types.v1.AgentInput
	8,  // 1: sdk_types.v1.ToolInput.ask_user_question:type_name -> sdk_types.v1.AskUserQuestionInput
	9,  // 2: sdk_types.v1.ToolInput.bash:type_name -> sdk_types.v1.BashInput
	10, // 3: sdk_types.v1.ToolInput.bash_output:type_name -> sdk_types.v1.BashOutputInput
	11, // 4: sdk_types.v1.ToolInput.file_edit:type_name -> sdk_types.v1.FileEditInput
	12, // 5: sdk_types.v1.ToolInput.file_read:type_name -> sdk_types.v1.FileReadInput
	13, // 6: sdk_types.v1.ToolInput.file_write:type_name -> sdk_types.v1.FileWriteInput
	14, // 7: sdk_types.v1.ToolInput.glob:type_name -> sdk_types.v1.GlobInput
	15, // 8: sdk_types.v1.ToolInput.grep:type_name -> sdk_types.v1.GrepInput
	16, // 9: sdk_types.v1.ToolInput.kill_shell:type_name -> sdk_types.v1.KillShellInput
	17, // 10: sdk_types.v1.ToolInput.notebook_edit:type_name -> sdk_types.v1.NotebookEditInput
	18, // 11: sdk_types.v1.ToolInput.web_fetch:type_name -> sdk_types.v1.WebFetchInput
	19, // 12: sdk_types.v1.ToolInput.web_search:type_name -> sdk_types.v1.WebSearchInput
	21, // 13: sdk_types.v1.ToolInput.todo_write:type_name -> sdk_types.v1.TodoWriteInput
	22, // 14: sdk_types.v1.ToolInput.exit_plan_mode:type_name -> sdk_types.v1.ExitPlanModeInput
	23, // 15: sdk_types.v1.ToolInput.list_mcp_resources:type_name -> sdk_types.v1.ListMcpResourcesInput
	24, // 16: sdk_types.v1.ToolInput.read_mcp_resource:type_name -> sdk_types.v1.ReadMcpResourceInput
	26, // 17: sdk_types.v1.ToolInput.mcp_tool:type_name -> google.protobuf.Struct
	6,  // 18: sdk_types.v1.Question.options:type_name -> sdk_types.v1.QuestionOption
	7,  // 19: sdk_types.v1.AskUserQuestionInput.questions:type_name -> sdk_types.v1.Question
	25, // 20: sdk_types.v1.AskUserQuestionInput.answers:type_name -> sdk_types.v1.AskUserQuestionInput.AnswersEntry
	0,  // 21: sdk_types.v1.GrepInput.output_mode:type_name -> sdk_types.v1.GrepOutputMode
	1,  // 22: sdk_types.v1.NotebookEditInput.cell_type:type_name -> sdk_types.v1.NotebookCellType
	2,  // 23: sdk_types.v1.NotebookEditInput.edit_mode:type_name -> sdk_types.v1.NotebookEditMode
	3,  // 24: sdk_types.v1.TodoItem.status:type_name -> sdk_types.v1.TodoStatus
	20, // 25: sdk_types.v1.TodoWriteInput.todos:type_name -> sdk_types.v1.TodoItem
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_sdk_types_v1_tool_input_proto_init() }
func file_sdk_types_v1_tool_input_proto_init() {
	if File_sdk_types_v1_tool_input_proto != nil {
		return
	}
	file_sdk_types_v1_tool_input_proto_msgTypes[0].OneofWrappers = []any{
		(*ToolInput_Agent)(nil),
		(*ToolInput_AskUserQuestion)(nil),
		(*ToolInput_Bash)(nil),
		(*ToolInput_BashOutput)(nil),
		(*ToolInput_FileEdit)(nil),
		(*ToolInput_FileRead)(nil),
		(*ToolInput_FileWrite)(nil),
		(*ToolInput_Glob)(nil),
		(*ToolInput_Grep)(nil),
		(*ToolInput_KillShell)(nil),
		(*ToolInput_NotebookEdit)(nil),
		(*ToolInput_WebFetch)(nil),
		(*ToolInput_WebSearch)(nil),
		(*ToolInput_TodoWrite)(nil),
		(*ToolInput_ExitPlanMode)(nil),
		(*ToolInput_ListMcpResources)(nil),
		(*ToolInput_ReadMcpResource)(nil),
		(*ToolInput_McpTool)(nil),
	}
	file_sdk_types_v1_tool_input_proto_msgTypes[5].OneofWrappers = []any{}
	file_sdk_types_v1_tool_input_proto_msgTypes[6].OneofWrappers = []any{}
	file_sdk_types_v1_tool_input_proto_msgTypes[7].OneofWrappers = []any{}
	file_sdk_types_v1_tool_input_proto_msgTypes[8].OneofWrappers = []any{}
	file_sdk_types_v1_tool_input_proto_msgTypes[10].OneofWrappers = []any{}
	file_sdk_types_v1_tool_input_proto_msgTypes[11].OneofWrappers = []any{}
	file_sdk_types_v1_tool_input_proto_msgTypes[13].OneofWrappers = []any{}
	file_sdk_types_v1_tool_input_proto_msgTypes[19].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_sdk_types_v1_tool_input_proto_rawDesc), len(file_sdk_types_v1_tool_input_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sdk_types_v1_tool_input_proto_goTypes,
		DependencyIndexes: file_sdk_types_v1_tool_input_proto_depIdxs,
		EnumInfos:         file_sdk_types_v1_tool_input_proto_enumTypes,
		MessageInfos:      file_sdk_types_v1_tool_input_proto_msgTypes,
	}.Build()
	File_sdk_types_v1_tool_input_proto = out.File
	file_sdk_types_v1_tool_input_proto_goTypes = nil
	file_sdk_types_v1_tool_input_proto_depIdxs = nil
}
