// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: permission/v1/permission.proto

package permissionv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PermissionDecision represents the possible permission decisions.
type PermissionDecision int32

const (
	PermissionDecision_PERMISSION_DECISION_UNSPECIFIED PermissionDecision = 0
	// Allow the tool to proceed.
	PermissionDecision_PERMISSION_DECISION_ALLOW PermissionDecision = 1
	// Block the tool execution.
	PermissionDecision_PERMISSION_DECISION_DENY PermissionDecision = 2
	// Prompt the user for confirmation.
	PermissionDecision_PERMISSION_DECISION_ASK PermissionDecision = 3
)

// Enum value maps for PermissionDecision.
var (
	PermissionDecision_name = map[int32]string{
		0: "PERMISSION_DECISION_UNSPECIFIED",
		1: "PERMISSION_DECISION_ALLOW",
		2: "PERMISSION_DECISION_DENY",
		3: "PERMISSION_DECISION_ASK",
	}
	PermissionDecision_value = map[string]int32{
		"PERMISSION_DECISION_UNSPECIFIED": 0,
		"PERMISSION_DECISION_ALLOW":       1,
		"PERMISSION_DECISION_DENY":        2,
		"PERMISSION_DECISION_ASK":         3,
	}
)

func (x PermissionDecision) Enum() *PermissionDecision {
	p := new(PermissionDecision)
	*p = x
	return p
}

func (x PermissionDecision) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PermissionDecision) Descriptor() protoreflect.EnumDescriptor {
	return file_permission_v1_permission_proto_enumTypes[0].Descriptor()
}

func (PermissionDecision) Type() protoreflect.EnumType {
	return &file_permission_v1_permission_proto_enumTypes[0]
}

func (x PermissionDecision) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PermissionDecision.Descriptor instead.
func (PermissionDecision) EnumDescriptor() ([]byte, []int) {
	return file_permission_v1_permission_proto_rawDescGZIP(), []int{0}
}

// PermissionRequest contains the hook input from Claude Code.
type PermissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the hook being invoked (e.g., "PreToolUse", "PostToolUse").
	HookEventName string `protobuf:"bytes,1,opt,name=hook_event_name,json=hookEventName,proto3" json:"hook_event_name,omitempty"`
	// The name of the tool being used (e.g., "Bash", "Write", "Edit").
	ToolName string `protobuf:"bytes,2,opt,name=tool_name,json=toolName,proto3" json:"tool_name,omitempty"`
	// The tool input as a JSON string.
	ToolInputJson string `protobuf:"bytes,3,opt,name=tool_input_json,json=toolInputJson,proto3" json:"tool_input_json,omitempty"`
	// Session ID from Claude Code.
	SessionId string `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Message ID from Claude Code.
	MessageId string `protobuf:"bytes,5,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Current working directory.
	Cwd string `protobuf:"bytes,6,opt,name=cwd,proto3" json:"cwd,omitempty"`
	// Path to conversation transcript.
	TranscriptPath string `protobuf:"bytes,7,opt,name=transcript_path,json=transcriptPath,proto3" json:"transcript_path,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PermissionRequest) Reset() {
	*x = PermissionRequest{}
	mi := &file_permission_v1_permission_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionRequest) ProtoMessage() {}

func (x *PermissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_permission_v1_permission_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionRequest.ProtoReflect.Descriptor instead.
func (*PermissionRequest) Descriptor() ([]byte, []int) {
	return file_permission_v1_permission_proto_rawDescGZIP(), []int{0}
}

func (x *PermissionRequest) GetHookEventName() string {
	if x != nil {
		return x.HookEventName
	}
	return ""
}

func (x *PermissionRequest) GetToolName() string {
	if x != nil {
		return x.ToolName
	}
	return ""
}

func (x *PermissionRequest) GetToolInputJson() string {
	if x != nil {
		return x.ToolInputJson
	}
	return ""
}

func (x *PermissionRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *PermissionRequest) GetMessageId() string {
	if x != nil {
		return x.MessageId
	}
	return ""
}

func (x *PermissionRequest) GetCwd() string {
	if x != nil {
		return x.Cwd
	}
	return ""
}

func (x *PermissionRequest) GetTranscriptPath() string {
	if x != nil {
		return x.TranscriptPath
	}
	return ""
}

// PermissionResponse contains the decision from the interactive server.
type PermissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the agent should continue after this hook (default: true).
	ShouldContinue bool `protobuf:"varint,1,opt,name=should_continue,json=shouldContinue,proto3" json:"should_continue,omitempty"`
	// Message shown when should_continue is false.
	StopReason string `protobuf:"bytes,2,opt,name=stop_reason,json=stopReason,proto3" json:"stop_reason,omitempty"`
	// Hide stdout from the transcript.
	SuppressOutput bool `protobuf:"varint,3,opt,name=suppress_output,json=suppressOutput,proto3" json:"suppress_output,omitempty"`
	// Message injected into the conversation for Claude to see.
	SystemMessage string `protobuf:"bytes,4,opt,name=system_message,json=systemMessage,proto3" json:"system_message,omitempty"`
	// The hook-specific output.
	HookSpecificOutput *HookSpecificOutput `protobuf:"bytes,5,opt,name=hook_specific_output,json=hookSpecificOutput,proto3" json:"hook_specific_output,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PermissionResponse) Reset() {
	*x = PermissionResponse{}
	mi := &file_permission_v1_permission_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionResponse) ProtoMessage() {}

func (x *PermissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_permission_v1_permission_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermissionResponse.ProtoReflect.Descriptor instead.
func (*PermissionResponse) Descriptor() ([]byte, []int) {
	return file_permission_v1_permission_proto_rawDescGZIP(), []int{1}
}

func (x *PermissionResponse) GetShouldContinue() bool {
	if x != nil {
		return x.ShouldContinue
	}
	return false
}

func (x *PermissionResponse) GetStopReason() string {
	if x != nil {
		return x.StopReason
	}
	return ""
}

func (x *PermissionResponse) GetSuppressOutput() bool {
	if x != nil {
		return x.SuppressOutput
	}
	return false
}

func (x *PermissionResponse) GetSystemMessage() string {
	if x != nil {
		return x.SystemMessage
	}
	return ""
}

func (x *PermissionResponse) GetHookSpecificOutput() *HookSpecificOutput {
	if x != nil {
		return x.HookSpecificOutput
	}
	return nil
}

// HookSpecificOutput contains hook-specific output data.
type HookSpecificOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hook event name this output is for.
	HookEventName string `protobuf:"bytes,1,opt,name=hook_event_name,json=hookEventName,proto3" json:"hook_event_name,omitempty"`
	// Permission decision: "allow", "deny", or "ask".
	PermissionDecision PermissionDecision `protobuf:"varint,2,opt,name=permission_decision,json=permissionDecision,proto3,enum=permission.v1.PermissionDecision" json:"permission_decision,omitempty"`
	// Explanation for the decision.
	PermissionDecisionReason string `protobuf:"bytes,3,opt,name=permission_decision_reason,json=permissionDecisionReason,proto3" json:"permission_decision_reason,omitempty"`
	// Modified tool input as a JSON string (requires permission_decision ALLOW).
	UpdatedInputJson string `protobuf:"bytes,4,opt,name=updated_input_json,json=updatedInputJson,proto3" json:"updated_input_json,omitempty"`
	// Context added to the conversation.
	AdditionalContext string `protobuf:"bytes,5,opt,name=additional_context,json=additionalContext,proto3" json:"additional_context,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *HookSpecificOutput) Reset() {
	*x = HookSpecificOutput{}
	mi := &file_permission_v1_permission_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HookSpecificOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HookSpecificOutput) ProtoMessage() {}

func (x *HookSpecificOutput) ProtoReflect() protoreflect.Message {
	mi := &file_permission_v1_permission_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HookSpecificOutput.ProtoReflect.Descriptor instead.
func (*HookSpecificOutput) Descriptor() ([]byte, []int) {
	return file_permission_v1_permission_proto_rawDescGZIP(), []int{2}
}

func (x *HookSpecificOutput) GetHookEventName() string {
	if x != nil {
		return x.HookEventName
	}
	return ""
}

func (x *HookSpecificOutput) GetPermissionDecision() PermissionDecision {
	if x != nil {
		return x.PermissionDecision
	}
	return PermissionDecision_PERMISSION_DECISION_UNSPECIFIED
}

func (x *HookSpecificOutput) GetPermissionDecisionReason() string {
	if x != nil {
		return x.PermissionDecisionReason
	}
	return ""
}

func (x *HookSpecificOutput) GetUpdatedInputJson() string {
	if x != nil {
		return x.UpdatedInputJson
	}
	return ""
}

func (x *HookSpecificOutput) GetAdditionalContext() string {
	if x != nil {
		return x.AdditionalContext
	}
	return ""
}

// AuditEvent represents a hook invocation event for audit logging.
type AuditEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The permission request data from the hook invocation.
	Request *PermissionRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	// The time the hook was invoked.
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuditEvent) Reset() {
	*x = AuditEvent{}
	mi := &file_permission_v1_permission_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuditEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuditEvent) ProtoMessage() {}

func (x *AuditEvent) ProtoReflect() protoreflect.Message {
	mi := &file_permission_v1_permission_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuditEvent.ProtoReflect.Descriptor instead.
func (*AuditEvent) Descriptor() ([]byte, []int) {
	return file_permission_v1_permission_proto_rawDescGZIP(), []int{3}
}

func (x *AuditEvent) GetRequest() *PermissionRequest {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *AuditEvent) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

// AuditResponse is returned after processing all audit events in the stream.
type AuditResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of events received in the stream.
	EventsReceived int32 `protobuf:"varint,1,opt,name=events_received,json=eventsReceived,proto3" json:"events_received,omitempty"`
	// Whether all events were processed successfully.
	Success bool `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	// Optional message with details about the processing result.
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuditResponse) Reset() {
	*x = AuditResponse{}
	mi := &file_permission_v1_permission_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuditResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuditResponse) ProtoMessage() {}

func (x *AuditResponse) ProtoReflect() protoreflect.Message {
	mi := &file_permission_v1_permission_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuditResponse.ProtoReflect.Descriptor instead.
func (*AuditResponse) Descriptor() ([]byte, []int) {
	return file_permission_v1_permission_proto_rawDescGZIP(), []int{4}
}

func (x *AuditResponse) GetEventsReceived() int32 {
	if x != nil {
		return x.EventsReceived
	}
	return 0
}

func (x *AuditResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AuditResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_permission_v1_permission_proto protoreflect.FileDescriptor

const file_permission_v1_permission_proto_rawDesc = "" +
	"\n" +
	"\x1epermission/v1/permission.proto\x12\rpermission.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xf9\x01\n" +
	"\x11PermissionRequest\x12&\n" +
	"\x0fhook_event_name\x18\x01 \x01(\tR\rhookEventName\x12\x1b\n" +
	"\ttool_name\x18\x02 \x01(\tR\btoolName\x12&\n" +
	"\x0ftool_input_json\x18\x03 \x01(\tR\rtoolInputJson\x12\x1d\n" +
	"\n" +
	"session_id\x18\x04 \x01(\tR\tsessionId\x12\x1d\n" +
	"\n" +
	"message_id\x18\x05 \x01(\tR\tmessageId\x12\x10\n" +
	"\x03cwd\x18\x06 \x01(\tR\x03cwd\x12'\n" +
	"\x0ftranscript_path\x18\a \x01(\tR\x0etranscriptPath\"\x83\x02\n" +
	"\x12PermissionResponse\x12'\n" +
	"\x0fshould_continue\x18\x01 \x01(\bR\x0eshouldContinue\x12\x1f\n" +
	"\vstop_reason\x18\x02 \x01(\tR\n" +
	"stopReason\x12'\n" +
	"\x0fsuppress_output\x18\x03 \x01(\bR\x0esuppressOutput\x12%\n" +
	"\x0esystem_message\x18\x04 \x01(\tR\rsystemMessage\x12S\n" +
	"\x14hook_specific_output\x18\x05 \x01(\v2!.permission.v1.HookSpecificOutputR\x12hookSpecificOutput\"\xab\x02\n" +
	"\x12HookSpecificOutput\x12&\n" +
	"\x0fhook_event_name\x18\x01 \x01(\tR\rhookEventName\x12R\n" +
	"\x13permission_decision\x18\x02 \x01(\x0e2!.permission.v1.PermissionDecisionR\x12permissionDecision\x12<\n" +
	"\x1apermission_decision_reason\x18\x03 \x01(\tR\x18permissionDecisionReason\x12,\n" +
	"\x12updated_input_json\x18\x04 \x01(\tR\x10updatedInputJson\x12-\n" +
	"\x12additional_context\x18\x05 \x01(\tR\x11additionalContext\"\x82\x01\n" +
	"\n" +
	"AuditEvent\x12:\n" +
	"\arequest\x18\x01 \x01(\v2 .permission.v1.PermissionRequestR\arequest\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\"l\n" +
	"\rAuditResponse\x12'\n" +
	"\x0fevents_received\x18\x01 \x01(\x05R\x0eeventsReceived\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage*\x93\x01\n" +
	"\x12PermissionDecision\x12#\n" +
	"\x1fPERMISSION_DECISION_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19PERMISSION_DECISION_ALLOW\x10\x01\x12\x1c\n" +
	"\x18PERMISSION_DECISION_DENY\x10\x02\x12\x1b\n" +
	"\x17PERMISSION_DECISION_ASK\x10\x032\xb1\x01\n" +
	"\x11PermissionService\x12X\n" +
	"\x11RequestPermission\x12 .permission.v1.PermissionRequest\x1a!.permission.v1.PermissionResponse\x12B\n" +
	"\x05Audit\x12\x19.permission.v1.AuditEvent\x1a\x1c.permission.v1.AuditResponse(\x01B\xc1\x01\n" +
	"\x11com.permission.v1B\x0fPermissionProtoP\x01ZFgithub.com/ngicks/crabswarm/hook/api/gen/go/permission/v1;permissionv1\xa2\x02\x03PXX\xaa\x02\rPermission.V1\xca\x02\rPermission\\V1\xe2\x02\x19Permission\\V1\\GPBMetadata\xea\x02\x0ePermission::V1b\x06proto3"

var (
	file_permission_v1_permission_proto_rawDescOnce sync.Once
	file_permission_v1_permission_proto_rawDescData []byte
)

func file_permission_v1_permission_proto_rawDescGZIP() []byte {
	file_permission_v1_permission_proto_rawDescOnce.Do(func() {
		file_permission_v1_permission_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_permission_v1_permission_proto_rawDesc), len(file_permission_v1_permission_proto_rawDesc)))
	})
	return file_permission_v1_permission_proto_rawDescData
}

var file_permission_v1_permission_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_permission_v1_permission_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_permission_v1_permission_proto_goTypes = []any{
	(PermissionDecision)(0),       // 0: permission.v1.PermissionDecision
	(*PermissionRequest)(nil),     // 1: permission.v1.PermissionRequest
	(*PermissionResponse)(nil),    // 2: permission.v1.PermissionResponse
	(*HookSpecificOutput)(nil),    // 3: permission.v1.HookSpecificOutput
	(*AuditEvent)(nil),            // 4: permission.v1.AuditEvent
	(*AuditResponse)(nil),         // 5: permission.v1.AuditResponse
	(*timestamppb.Timestamp)(nil), // 6: google.protobuf.Timestamp
}
var file_permission_v1_permission_proto_depIdxs = []int32{
	3, // 0: permission.v1.PermissionResponse.hook_specific_output:type_name -> permission.v1.HookSpecificOutput
	0, // 1: permission.v1.HookSpecificOutput.permission_decision:type_name -> permission.v1.PermissionDecision
	1, // 2: permission.v1.AuditEvent.request:type_name -> permission.v1.PermissionRequest
	6, // 3: permission.v1.AuditEvent.timestamp:type_name -> google.protobuf.Timestamp
	1, // 4: permission.v1.PermissionService.RequestPermission:input_type -> permission.v1.PermissionRequest
	4, // 5: permission.v1.PermissionService.Audit:input_type -> permission.v1.AuditEvent
	2, // 6: permission.v1.PermissionService.RequestPermission:output_type -> permission.v1.PermissionResponse
	5, // 7: permission.v1.PermissionService.Audit:output_type -> permission.v1.AuditResponse
	6, // [6:8] is the sub-list for method output_type
	4, // [4:6] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_permission_v1_permission_proto_init() }
func file_permission_v1_permission_proto_init() {
	if File_permission_v1_permission_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_permission_v1_permission_proto_rawDesc), len(file_permission_v1_permission_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_permission_v1_permission_proto_goTypes,
		DependencyIndexes: file_permission_v1_permission_proto_depIdxs,
		EnumInfos:         file_permission_v1_permission_proto_enumTypes,
		MessageInfos:      file_permission_v1_permission_proto_msgTypes,
	}.Build()
	File_permission_v1_permission_proto = out.File
	file_permission_v1_permission_proto_goTypes = nil
	file_permission_v1_permission_proto_depIdxs = nil
}
